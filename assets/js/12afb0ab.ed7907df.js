"use strict";(self.webpackChunkfiredbg=self.webpackChunkfiredbg||[]).push([[399],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),d=i,m=c["".concat(s,".").concat(d)]||c[d]||h[d]||a;return n?r.createElement(m,l(l({ref:t},p),{},{components:n})):r.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var u=2;u<a;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7236:(e,t,n)=>{n.d(t,{E:()=>a,n:()=>i});var r=n(7294);function i(e){let{src:t}=e;const n=t.replace("-dark","-light"),i=t.replace("-light","-dark");return r.createElement(r.Fragment,null,r.createElement("video",{controls:!0,muted:!0,autoPlay:!0,loop:!0,style:{width:"100%"},"data-theme":"light"},r.createElement("source",{src:n,type:"video/mp4"})),r.createElement("video",{controls:!0,muted:!0,autoPlay:!0,loop:!0,style:{width:"100%"},"data-theme":"dark"},r.createElement("source",{src:i,type:"video/mp4"})))}function a(e){const t=e.src.replace("-dark","-light"),n=e.src.replace("-light","-dark"),i=()=>r.createElement(r.Fragment,null,r.createElement("img",{style:{width:"100%"},src:`${t}#light`}),r.createElement("img",{style:{width:"100%"},src:`${n}#dark`}));return void 0===e.children?i():r.createElement("table",null,r.createElement("tbody",null,r.createElement("tr",{style:{backgroundColor:"unset"}},r.createElement("td",null,i())),r.createElement("tr",{style:{backgroundColor:"unset"}},r.createElement("td",{style:{color:"var(--ifm-blockquote-color)"}},e.children))))}},2591:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var r=n(7462),i=(n(7294),n(3905)),a=n(7236);const l={slug:"2024-06-30-fizzbuzz-multithread",title:"FizzBuzz Multithreaded - synchronization with rendezvous channels",author:"Chris Tsang",author_title:"FireDBG Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",image:"https://firedbg.sea-ql.org/img/fizzbuzz-multithread.png",tags:["news"]},o=void 0,s={permalink:"/blog/2024-06-30-fizzbuzz-multithread",editUrl:"https://github.com/SeaQL/firedbg.sea-ql.org/edit/main/FireDBG/blog/blog/2024-06-30-fizzbuzz-multithread.mdx",source:"@site/blog/2024-06-30-fizzbuzz-multithread.mdx",title:"FizzBuzz Multithreaded - synchronization with rendezvous channels",description:'This post serves as the "Part 3" of the article "The rainbow bridge between sync and async Rust", today we will discuss:',date:"2024-06-30T00:00:00.000Z",formattedDate:"June 30, 2024",tags:[{label:"news",permalink:"/blog/tags/news"}],readingTime:6.66,hasTruncateMarker:!1,authors:[{name:"Chris Tsang",title:"FireDBG Team",url:"https://github.com/tyt2y3",imageURL:"https://avatars.githubusercontent.com/u/1782664?v=4"}],frontMatter:{slug:"2024-06-30-fizzbuzz-multithread",title:"FizzBuzz Multithreaded - synchronization with rendezvous channels",author:"Chris Tsang",author_title:"FireDBG Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",image:"https://firedbg.sea-ql.org/img/fizzbuzz-multithread.png",tags:["news"]},nextItem:{title:"Visualizing Dynamic Programming - Part 1",permalink:"/blog/2024-01-31-visual-dynamic-program"}},u={authorsImageUrls:[void 0]},p=[{value:"Problem",id:"problem",level:2},{value:"Multi-thread",id:"multi-thread",level:2},{value:"Race condition",id:"race-condition",level:2},{value:"Solution",id:"solution",level:2},{value:"FireDBG",id:"firedbg",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}],c={toc:p},h="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("img",{src:"/img/fizzbuzz-multithread.png",style:{borderRadius:"25px",maxHeight:"50vh"}}),(0,i.kt)("p",null,'This post serves as the "Part 3" of the article ',(0,i.kt)("a",{parentName:"p",href:"https://www.sea-ql.org/blog/2024-05-20-async-rainbow-bridge/"},'"The rainbow bridge between sync and async Rust"'),", today we will discuss:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The fundamentals of multithreaded programming"),(0,i.kt)("li",{parentName:"ol"},"Synchronization with zero-sized channels"),(0,i.kt)("li",{parentName:"ol"},"Visualizing multithreaded programs with FireDBG")),(0,i.kt)("p",null,"I've been thinking of the simplest program that can demonstrate the use of zero-sized channels in a multithreaded context, and no programming exercise can be simpler than FizzBuzz!"),(0,i.kt)("h2",{id:"problem"},"Problem"),(0,i.kt)("p",null,"Here is the ",(0,i.kt)("a",{parentName:"p",href:"https://blog.codinghorror.com/why-cant-programmers-program/"},"original description")," of the problem:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Write a program that prints the numbers from 1 to 100.\nBut for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz".\nFor numbers which are multiples of both three and five print "FizzBuzz".\n')),(0,i.kt)("p",null,"With an additional requirement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Fizz and Buzz must be printed from different threads.\n")),(0,i.kt)("p",null,"To keep things simple, the printing of numbers and Fizz can happen on the same thread. So we only need two threads for this problem."),(0,i.kt)("p",null,"Let's look at the basic solution to the original FizzBuzz problem:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    for i in 1..=100 {\n        if i % 15 == 0 {\n            println!("FizzBuzz");\n        } else if i % 3 == 0 {\n            println!("Fizz");\n        } else if i % 5 == 0 {\n            println!("Buzz");\n        } else {\n            println!("{i}");\n        }\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=770db820c71661a83f259df84ce133d7"},"Playground")),(0,i.kt)("p",null,"It prints something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\nFizz\n22\n23\nFizz\nBuzz\n26\nFizz\n28\n29\nFizzBuzz\n...\n")),(0,i.kt)("h2",{id:"multi-thread"},"Multi-thread"),(0,i.kt)("p",null,"We want to move Buzz to a different thread. Let's take a closer look to the core logic:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'if i % 15 == 0 {\n    print!("Fizz");\n    println!("Buzz"); // <- move this to a different thread\n} else if i % 3 == 0 {\n    println!("Fizz");\n} else if i % 5 == 0 {\n    println!("Buzz"); // <- also move this\n} else {\n    println!("{i}");\n}\n')),(0,i.kt)("p",null,'Here is where channels come into play. We want to notify the other thread - "hey it\'s time for you to buzz!".'),(0,i.kt)("p",null,'We want to use a "zero-sized" channel, because we want our Fizz thread to wait until the Buzz thread is ready to print.'),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/std/sync/mpsc/struct.SyncSender.html#method.send"},(0,i.kt)("inlineCode",{parentName:"a"},"SyncSender::send()"))," method is blocking, i.e."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This function will block until space in the internal buffer becomes available or a receiver is available to hand off the message to."),(0,i.kt)("p",{parentName:"blockquote"},"If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.")),(0,i.kt)("p",null,"Because there is only one thing we need to notify, we can send ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," - the zero-sized type."),(0,i.kt)("p",null,"Based on the examples in the ",(0,i.kt)("a",{parentName:"p",href:"https://www.sea-ql.org/blog/2024-05-20-async-rainbow-bridge/"},"previous post"),", we can try construct the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc::{sync_channel, Receiver, SyncSender};\n\nfn fizzer(sender: SyncSender<()>) {\n    for i in 1..=100 {\n        if i % 15 == 0 {\n            print!("Fizz");\n            sender.send(()).unwrap();\n        } else if i % 3 == 0 {\n            println!("Fizz");\n        } else if i % 5 == 0 {\n            sender.send(()).unwrap();\n        } else {\n            println!("{i}");\n        }\n    }\n}\n\nfn buzzer(receiver: Receiver<()>) {\n    while let Ok(()) = receiver.recv() {\n        println!("Buzz");\n    }\n}\n\nfn main() {\n    let (sender, receiver) = sync_channel(0); // zero sized\n    std::thread::spawn(move || buzzer(receiver));\n\n    fizzer(sender);\n}\n')),(0,i.kt)("h2",{id:"race-condition"},"Race condition"),(0,i.kt)("p",null,"Neat, this should work right? Let's give it a try. Since this is a multi-threaded program, let's run it a few times:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"1st"),(0,i.kt)("th",{parentName:"tr",align:"center"},"2nd"),(0,i.kt)("th",{parentName:"tr",align:"center"},"3rd"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1",(0,i.kt)("br",null),"2",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"4",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"7",(0,i.kt)("br",null),"8",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"11",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"13",(0,i.kt)("br",null),"14",(0,i.kt)("br",null),"Fizz16",(0,i.kt)("br",null),"17",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"19",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"Buzz"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1",(0,i.kt)("br",null),"2",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"4",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"7",(0,i.kt)("br",null),"8",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"11",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"13",(0,i.kt)("br",null),"14",(0,i.kt)("br",null),"FizzBuzz",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"16",(0,i.kt)("br",null),"17",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"19",(0,i.kt)("br",null),"Fizz"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1",(0,i.kt)("br",null),"2",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"4",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"7",(0,i.kt)("br",null),"8",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"11",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"13",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"14",(0,i.kt)("br",null),"Fizz16",(0,i.kt)("br",null),"17",(0,i.kt)("br",null),"Fizz",(0,i.kt)("br",null),"19",(0,i.kt)("br",null),"Buzz",(0,i.kt)("br",null),"Buzz")))),(0,i.kt)("p",null,"Sad, it doesn't look deterministic. The first Buzz is in the right place, but subsequent Buzzes are in the wrong places. There are ... race conditions!"),(0,i.kt)("p",null,"But why?"),(0,i.kt)("p",null,"Here is what should have happened:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1: Fizz thread sends a signal\n2: Buzz thread receives a signal\n3: Buzz prints\n4: Fizz thread continues running\n5. Print other numbers\n")),(0,i.kt)("p",null,"Here is what could have happened:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1: Fizz thread sends a signal\n2: Buzz thread receives a signal\n4: Fizz thread continues running\n5. Print other numbers\n3: Buzz prints\n")),(0,i.kt)("p",null,"Turns out, the channel and signal only guarantees the relative order of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", but everything afterwards can happen in arbitrary order!"),(0,i.kt)("p",null,"This is the rule of thumb of multithreaded / parallel programming: if we don't make explicit attempt to synchronize different actors, we cannot assume things will happen in a particular order."),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"The solution to the above problem is simple: Fizz thread has to wait until Buzz thread finishes printing. There can be multiple ways to implement this, e.g. with a ",(0,i.kt)("inlineCode",{parentName:"p"},"request-response")," design, or with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Future")," that only completes after printing."),(0,i.kt)("p",null,"The simplest solution here though, is to send signal in successive pairs, with even signal open and odd signal close."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc::{sync_channel, Receiver, SyncSender};\n\nfn fizzer(sender: SyncSender<()>) {\n    for i in 1..=100 {\n        if i % 15 == 0 {\n            print!("Fizz");\n            sender.send(()).unwrap();\n            sender.send(()).unwrap(); // <-\n        } else if i % 3 == 0 {\n            println!("Fizz");\n        } else if i % 5 == 0 {\n            sender.send(()).unwrap();\n            sender.send(()).unwrap(); // <-\n        } else {\n            println!("{i}");\n        }\n    }\n}\n\nfn buzzer(receiver: Receiver<()>) {\n    while let Ok(()) = receiver.recv() {\n        println!("Buzz");\n        receiver.recv().unwrap(); // <-\n    }\n}\n\nfn main() {\n    let (sender, receiver) = sync_channel(0);\n    std::thread::spawn(move || buzzer(receiver));\n\n    fizzer(sender);\n}\n')),(0,i.kt)("p",null,'There is no material transfer here, but the first rendezvous can be thought as "I hand over the lock to print now", and the second is thus "now return the print lock to me". Here ',(0,i.kt)("inlineCode",{parentName:"p"},"()")," represents an imaginary lock."),(0,i.kt)("p",null,"If you think this is clever, subtle and intricate, you're right. Yes parallel programming can be intimidating and error-prone."),(0,i.kt)("h2",{id:"firedbg"},"FireDBG"),(0,i.kt)("p",null,"With FireDBG, we can actually visualize the events happened in parallel threads!"),(0,i.kt)(a.E,{src:"/img/fizzbuzz-multithread-dark.png",mdxType:"Image"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/fizzbuzz-multithread"},"Testbench with full source code")),(0,i.kt)("p",null,"In the above screenshot, we can see a snapshot at the precise moment of ",(0,i.kt)("inlineCode",{parentName:"p"},"i = 30"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'In the "Timeline" panel, there are two threads, the one with double line ',(0,i.kt)("inlineCode",{parentName:"li"},"==")," is the main thread, aka Fizz thread. The thread below ",(0,i.kt)("inlineCode",{parentName:"li"},"--")," is the Buzz thread."),(0,i.kt)("li",{parentName:"ol"},"On the timeline, ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb")," denotes function call, ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25a1")," denotes function return."),(0,i.kt)("li",{parentName:"ol"},"The first ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb-fizz-\u25a1")," from the left is for the number ",(0,i.kt)("inlineCode",{parentName:"li"},"27"),". The first ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb-buzz-\u25a1")," is for the number ",(0,i.kt)("inlineCode",{parentName:"li"},"25"),"."),(0,i.kt)("li",{parentName:"ol"},"The subsequent two ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb-I-\u25a1")," are for ",(0,i.kt)("inlineCode",{parentName:"li"},"28")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"29")," respectively."),(0,i.kt)("li",{parentName:"ol"},"The second ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb-fizz-\u25a1")," is highlighted (frame id ",(0,i.kt)("inlineCode",{parentName:"li"},"28"),"), and the state ",(0,i.kt)("inlineCode",{parentName:"li"},"i = 30"),' is show in the top "Variables" panel.'),(0,i.kt)("li",{parentName:"ol"},"We can see that the ",(0,i.kt)("inlineCode",{parentName:"li"},"\u25cb-buzz-\u25a1")," on the other thread returns before the main thread continues.")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this article we discussed:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The basics of multithreaded programming"),(0,i.kt)("li",{parentName:"ol"},"The pitfalls in causing race conditions and analysis"),(0,i.kt)("li",{parentName:"ol"},"Synchronization with zero-sized channels and a minimal protocol"),(0,i.kt)("li",{parentName:"ol"},"Visualizing multithreaded programs with FireDBG")),(0,i.kt)("p",null,"FireDBG can be used to study parallel algorithms in simulation, before scaling up to real-world distributed systems."),(0,i.kt)("p",null,"Probably the alternative title for this article can be ",(0,i.kt)("strong",{parentName:"p"},'"Rendezvous channel - the Timedoor between parallel threads"'),"."),(0,i.kt)("h2",{id:"rustacean-sticker-pack-"},"Rustacean Sticker Pack \ud83e\udd80"),(0,i.kt)("p",null,"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"),(0,i.kt)("p",null,"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."),(0,i.kt)("p",null,"Sticker Pack Contents:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, ",(0,i.kt)("strong",{parentName:"li"},"FireDBG")),(0,i.kt)("li",{parentName:"ul"},"Mascot of SeaQL: Terres the Hermit Crab"),(0,i.kt)("li",{parentName:"ul"},"Mascot of Rust: Ferris the Crab"),(0,i.kt)("li",{parentName:"ul"},"The Rustacean word")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.sea-ql.org/sticker-pack/"},"Support SeaQL and get a Sticker Pack!")),(0,i.kt)("a",{href:"https://www.sea-ql.org/sticker-pack/"},(0,i.kt)("img",{style:{borderRadius:"25px",maxHeight:"50vh"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})))}d.isMDXComponent=!0}}]);