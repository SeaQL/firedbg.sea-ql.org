"use strict";(self.webpackChunkfiredbg=self.webpackChunkfiredbg||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2023-12-13-getting-started","metadata":{"permalink":"/blog/2023-12-13-getting-started","editUrl":"https://github.com/SeaQL/firedbg.sea-ql.org/edit/main/FireDBG/blog/blog/2023-12-13-getting-started.mdx","source":"@site/blog/2023-12-13-getting-started.mdx","title":"Getting Started","description":"In this blog post, we will cover the basic usage of FireDBG VS Code Extension (\\"the Extension\\") and FireDBG CLI (\\"the CLI\\"). By the end of this tutorial, you will learn:","date":"2023-12-13T00:00:00.000Z","formattedDate":"December 13, 2023","tags":[{"label":"news","permalink":"/blog/tags/news"}],"readingTime":14.63,"hasTruncateMarker":false,"authors":[{"name":"Billy Chan","title":"FireDBG Team","url":"https://github.com/billy1624","imageURL":"https://avatars.githubusercontent.com/u/30400950?v=4"}],"frontMatter":{"slug":"2023-12-13-getting-started","title":"Getting Started","author":"Billy Chan","author_title":"FireDBG Team","author_url":"https://github.com/billy1624","author_image_url":"https://avatars.githubusercontent.com/u/30400950?v=4","image":"https://firedbg.sea-ql.org/img/banner-getting-started.png","tags":["news"]},"nextItem":{"title":"Introducing FireDBG for Rust","permalink":"/blog/2023-12-12-introducing-firedbg"}},"content":"import { Video, Image } from \'../src/themed.js\';\\n\\nIn this blog post, we will cover the basic usage of FireDBG VS Code Extension (\\"the Extension\\") and FireDBG CLI (\\"the CLI\\"). By the end of this tutorial, you will learn:\\n\\n- How to install the Extension and the CLI\\n- How to setup a Rust workspace for FireDBG debugger\\n- How to debug Rust binary, example, unit test and integration test with FireDBG debugger\\n- How to interpret and inspect visualized call tree, variables and timeline in the Extension\\n- How to interpret and inspect breakpoint events of multi-threaded program in the Extension\\n- How to trace any variable / expression of interest with the `fire::dbg!` trace macro\\n- How to selectively enable / disable tracing of a local package\\n- How to use the CLI to operate FireDBG debugger and then interpret and inspect breakpoint events via SQLite\\n\\nIf you\'re curious about the background and inner working of FireDBG\\n\\n- [Introducing FireDBG for Rust \ud83d\udd25](/blog/2023-12-12-introducing-firedbg)\\n- [Architecture of FireDBG](/blog/2023-12-11-architecture-of-firedbg)\\n\\n## Installation\\n\\nBefore we start, make sure you have VS Code and Rust installed.\\n\\n- VS Code (version 1.80.0 or later)\\n- Rust (version 1.74.0 or later)\\n\\n### Rust & Cargo\\n\\n```shell\\n# install rustup\\ncurl --proto \'=https\' --tlsv1.2 -sSf https://sh.rustup.rs | sh\\n# install stable\\nrustup install stable\\n```\\n\\n### FireDBG VS Code Extension\\n\\nThe Extension provides seamless integration with FireDBG to enhance debugging experience and developer productivity.\\nSearch and install the [`FireDBG`](https://marketplace.visualstudio.com/items?itemName=SeaQL.firedbg-rust) extension.\\n\\n#### Windows Notes\\n\\n<Image src=\\"/img/gt-windows-light.png\\"/>\\n\\nWe only support Windows under WSL 2 right now, so please follow these steps on Windows:\\n\\n0. Install [Ubuntu 22.04](https://apps.microsoft.com/detail/9PN20MSR04DW?hl=en-US&gl=US)\\n1. Install the [WSL extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl)\\n2. Click `><` on the bottom left, and select \\"Connect to WSL\\"\\n3. Install the [`FireDBG`](https://marketplace.visualstudio.com/items?itemName=SeaQL.firedbg-rust) extension\\n\\n### FireDBG Binaries\\n\\nTo keep the `.vsix` package small in size, we dont\'t ship the platform-specific binaries with the Extension.\\nInstead, we have a dedicated installer script for the FireDBG binaries. We provide prebuilt binaries for the following CPU and OS combination:\\n\\n|                | Linux[^1] | macOS[^2] | Windows (WSL 2)[^3] |\\n|---------------:|:---------:|:---------:|:-------------------:|\\n| x64            | \u2705        | \u2705 Intel | \u2705                   |\\n| arm64          | \u26d4\ufe0f        | \u2705 Apple | \u26d4\ufe0f                   |\\n\\nOnce the the Extension has been installed, you should see a prompt hinting that FireDBG binaries are missing. Click on the \\"install\\" button to run the installer.\\n\\n<Image src=\\"/img/gt-install-firedbg-light.png\\"/>\\n\\nOr, you can run the installer manually.\\n\\n```shell\\ncurl https://raw.githubusercontent.com/SeaQL/FireDBG.for.Rust/main/install.sh -sSf | sh\\n```\\n\\nFireDBG binaries will be installed in `~/.cargo/bin` and a debugger self test will be conducted to verify the installation. Expect to see:\\n\\n```shell\\ninfo: completed FireDBG self tests\\n```\\n\\nIn case you got error messages when performing self test, read [Troubleshooting Guide](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/Troubleshooting.md) for the solution of common errors.\\n\\n## GUI Tour\\n\\nDownload the [zipped source code](https://codeload.github.com/SeaQL/FireDBG.Rust.Testbench/zip/refs/heads/main), or cloning [Rust Testbench for FireDBG](https://github.com/SeaQL/FireDBG.Rust.Testbench) to your local machine, then follow the tour below to learn the basic usage of the Extension.\\n\\n```shell\\ngit clone git@github.com:SeaQL/FireDBG.Rust.Testbench.git\\n```\\n\\nNote that the root directory of testbench isn\'t a Cargo workspace. In the next section, please open each sub-folder (e.g. `getting-started`) in VS Code. For convenience, each example already included a sample run.\\n\\n### Debug Targets and Runs\\n\\nWhere can I see the list of all debuggable Rust targets, how can I debug it and how to inspect previous runs?\\n\\n<Image src=\\"/img/gt-debug-and-run-activate-light.png\\"/>\\n\\n1. Click on the \\"Run and Debug\\" panel on your primary sidebar, you should see two new panels on the bottom\\n2. Activate FireDBG\\n3. The `FIREDBG` panel should display all binaries, examples, integration tests and unit tests in your current Rust workspace. Click on the list item to reveal the Rust source code. To debug it, hover the list item and click on the play icon \u25b6\ufe0f on the list item. A new debugger view will be shown and tail the progress in real time. \\n4. All previous debug runs can be found in the `FIREDBG RUNS` panel, simply click on it to open.\\n\\nAlternatively, you can list all debuggable Rust targets with the CLI:\\n\\n```shell\\n$ firedbg list-target\\n\\nAvailable binaries are:\\n\\troll_dice\\n```\\n\\nAnd, list all previous runs with the CLI:\\n\\n```shell\\n$ firedbg list-run\\n\\nAvailable `firedbg` runs are:\\n    1) roll_dice-1701678002235.firedbg.ss\\n```\\n\\n### Visual Debugger\\n\\nHow to interpret and inspect visualized call tree, variables, timeline and threads in the Extension?\\n\\n<Image src=\\"/img/gt-vis-debugger-light.png\\"/>\\n\\nWe can the open the debugger view by clicking the items in the `FIREDBG RUNS` panel, or with the `open` command:\\n\\n```shell\\nfiredbg open\\n```\\n\\n1. Each node represent a function call; the depth of each node indicates the depth of the call stack; each node has a unique frame ID; there are two types of edge:\\n\\t- Function call with return value: `-<->-`\\n\\t- Function call only: `--\x3e--`\\n2. If the program exited with a panic, the panicking function will be highlighted in red with an exclamation mark.\\n3. Click on the function name on the call tree node to reveal the Rust source code.\\n4. Function Arguments: the name of the argument is shown as the label. The faded text on the bounding box denote the type name, where hovering on it will reveal the fully-qualified name. The actual value is enclosed in the bounding box.\\n5. Function Return Value: the return value will be shown on the far right with the label `return`.\\n6. Timeline: toggle the timline by checking the timeline checkbox on the bottom. There are two kinds of node:\\n    - Circle: function call\\n    - Square: function return\\n7. Thread selector: If the program has more than one thread, a dropdown will be shown on the bottom. You can switch to inspect the execution of other threads. Bring up the timeline to view the execution of all threads in a single view.\\n\\n#### Controls\\n\\nHow to navigate the program execution flow?\\n\\n<Image src=\\"/img/gt-vis-debugger-control-light.png\\"/>\\n\\n1. Use the control buttons on the timebar to jump to the beginning or the end of program execution. Use `J` `K` on your keyboard or stepping buttons `<` `>` to step one frame backward or forward. The unit of time on the timebar is frame ID of the selected thread. Clicking on the timebar would jump to the exact function call.\\n2. The visualization will be updated as you traverse the call tree. Use `W` `A` `S` `D` keys on your keyboard or your left mouse click to pan; Click the `+|-` buttons on the bottom right or `-` `=` on your keyboard or use your mouse scroll wheel to zoom.\\n\\nTo resize a panel, hover the mouse on the panel gutter then drag to resize. Tip: double clicking the gutter reverts the panel to a pre-defined size.\\n\\n### FireDBG Sidebar\\n\\nHow to retrieve detailed debug info?\\n\\n<Image src=\\"/img/gt-sidebar-light.png\\"/>\\n\\nThe FireDBG sidebar contains all debug info. It will be updated as you traverse the call tree.\\n\\n1. `Debugger Info`: FireDBG debugger info, program executable info and runtime info\\n2. `Frame Info`: frame metadata of the inspected function call\\n3. `Parameters`: Rust-like representation of the inspected function call\'s arguments\\n4. `Return Value`: Rust-like representation of the inspected function\'s return value\\n5. `Call Stack (Ancestors)`: ancestors of the inspected function; up until root\\n6. `Callee (Children)`: immediate children of the inspected function\\n\\n## FireDBG CLI\\n\\nThere are two ways to tell `firedbg` where is the root directory of a cargo workspace:\\n\\n1. By default, the current directory will be the root directory of a cargo workspace\\n2. Or, overriding it with `--workspace-root` option, i.e. `firedbg --workspace-root <WORKSPACE-ROOT>`\\n\\nSome common sub-commands include:\\n\\n- `cache`: Parse all `.rs` source files in the current workspace\\n- `clean`: Cleanup the `firedbg/` folder\\n- `list-target`: List all runnable targets\\n- `run`: Run a binary target with debugging enabled\\n- `example`: Run an example with debugging enabled\\n- `test`: Run an integrated test with debugging enabled\\n- `unit-test`: Run a unit test with debugging enabled\\n- `index`: Run indexer on the latest run and save it as a `.sqlite` db file\\n- `list-run`: List all `firedbg` runs\\n- `open`: Open debugger view in VS Code\\n- `help`: Print help message or the help of the given subcommand(s)\\n\\nYou can get the help messages by appending the `--help` flag.\\n\\n## FireDBG Workspace\\n\\n[Cargo workspace](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html) is a set of crates sharing the same `Cargo.lock` and `target` directory.\\nFireDBG rely on Cargo to locate source files and targets for debugging.\\n\\nNow you have a basic understanding on the usage of FireDBG.\\nLet\'s create a Cargo workspace and practice debugging with FireDBG!\\n\\n[Full source code](https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/getting-started) is available on our testbench.\\n\\n<Image src=\\"/img/gt-workspace-light.png\\"/>\\n\\nStart by creating a `getting-started` workspace.\\n\\n```shell\\n$ mkdir getting-started\\n$ cd getting-started\\n```\\n\\nFor now, we only have a single `quicksort` package in this workspace. We will add one more crate later.\\n\\n```toml title=\\"Cargo.toml\\"\\n[workspace]\\nmembers = [\\"quicksort\\"]\\n```\\n\\nTo create the `quicksort` library, we can use the convenient `cargo` command.\\n\\n```shell\\n$ cargo new --lib quicksort\\n$ cd quicksort\\n```\\n\\n### Debugging Unit Tests\\n\\nReplace the content of `lib.rs` with our \\"faulty\\" quick sort library code.\\n\\n```rust title=\\"quicksort/src/lib.rs\\"\\npub fn run<T: PartialOrd>(arr: &mut [T]) {\\n    let len = arr.len();\\n    quick_sort(arr, 0, (len - 1) as isize);\\n}\\n\\nfn quick_sort<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) {\\n    if low < high {\\n        let p = partition(arr, low, high);\\n        quick_sort(arr, low, p - 1);\\n        quick_sort(arr, p + 1, high);\\n    }\\n}\\n\\nfn partition<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) -> isize {\\n    let pivot = high as usize;\\n    let mut store_index = low; // Shouldn\'t this be `low - 1`?\\n    let mut last_index = high;\\n\\n    loop {\\n        store_index += 1;\\n        while arr[store_index as usize] < arr[pivot] {\\n            store_index += 1;\\n        }\\n        last_index -= 1;\\n        while last_index >= 0 && arr[last_index as usize] > arr[pivot] {\\n            last_index -= 1;\\n        }\\n        if store_index >= last_index {\\n            break;\\n        } else {\\n            arr.swap(store_index as usize, last_index as usize);\\n        }\\n    }\\n    arr.swap(store_index as usize, pivot as usize);\\n    store_index\\n}\\n```\\n\\nThen add some unit tests to the end of `lib.rs` file.\\n\\n```rust title=\\"quicksort/src/lib.rs\\"\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_quicksort_1() {\\n        let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\\n        run(&mut numbers);\\n        assert_eq!(numbers, [-31, 0, 1, 2, 2, 4, 65, 83, 99, 782]);\\n    }\\n\\n    #[test]\\n    fn test_quicksort_2() {\\n        let mut numbers = [1, 2, 2];\\n        run(&mut numbers);\\n        assert_eq!(numbers, [1, 2, 2]);\\n    }\\n}\\n```\\n\\nClick on the debug icon on the left to start debugging the unit test. Or with the CLI:\\n\\n```shell\\nfiredbg unit-test quicksort test::test_quicksort_1\\n```\\n\\nOooops... assertion failure!\\n\\n<Image src=\\"/img/gt-unit-test-light.png\\"/>\\n\\nWe found that it\'s quite hard to inspect what elements are swapped in each `partition`.\\nTo help debugging, we can add a `swap` function and rewrite the original code:\\n\\n```diff\\nfn partition<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) -> isize {\\n    let pivot = high as usize;\\n    let mut store_index = low - 1;\\n    let mut last_index = high;\\n\\n    loop {\\n        store_index += 1;\\n        while arr[store_index as usize] < arr[pivot] {\\n            store_index += 1;\\n        }\\n        last_index -= 1;\\n        while last_index >= 0 && arr[last_index as usize] > arr[pivot] {\\n            last_index -= 1;\\n        }\\n        if store_index >= last_index {\\n            break;\\n        } else {\\n-           arr.swap(store_index as usize, last_index as usize);\\n+           swap(&mut arr[store_index as usize..=last_index as usize]);\\n        }\\n    }\\n-   arr.swap(store_index as usize, pivot as usize);\\n+   swap(&mut arr[store_index as usize..=pivot as usize]);\\n    store_index\\n}\\n\\n+ fn swap<T: PartialOrd>(arr: &mut [T]) {\\n+     arr.swap(0, arr.len() - 1);\\n+ }\\n```\\n\\n> Tip: you can add `#[cfg_attr(not(debug_assertions), inline)]` to the `swap` function to inline it in release build, so that it will not incur any overhead.\\n\\nNow, we can clearly see what was swapped and how many times `swap` was called. Upon a closer inspection we will see a pattern, i.e. the first element is always untouched in all `partition` operations. That\'s the bug \ud83d\udc1b!\\n\\n<Image src=\\"/img/gt-unit-test-swap-light.png\\"/>\\n\\n### `fire::dbg!` Trace Macro\\n\\nLet\'s try to debug the same program with a different approach. An non-invasive approach, this time we only trace the swap without modifying the program structure.\\n\\nFireDBG provide a [`fire::dbg!`](https://docs.rs/firedbg-lib/latest/firedbg_lib/fire/macro.dbg.html) macro similar to [`std::dbg!`](https://doc.rust-lang.org/std/macro.dbg.html) to capture the variable of interest.\\n\\nWe can trace the swap actions with the help of `fire::dbg!`. The main advantage compared to `std::dbg!`, is that the trace data is associated with the stack frame of the calling function.\\n\\nUndo the previous change and go back to the original implementation.\\n\\n```diff title=\\"Cargo.toml\\"\\n[dependencies]\\n+ firedbg-lib = \\"0.1\\"\\n```\\n\\n```diff\\n+ use firedbg_lib::fire;\\n\\nfn partition<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) -> isize {\\n    let pivot = high as usize;\\n    let mut store_index = low - 1;\\n    let mut last_index = high;\\n\\n    loop {\\n        store_index += 1;\\n        while arr[store_index as usize] < arr[pivot] {\\n            store_index += 1;\\n        }\\n        last_index -= 1;\\n        while last_index >= 0 && arr[last_index as usize] > arr[pivot] {\\n            last_index -= 1;\\n        }\\n        if store_index >= last_index {\\n            break;\\n        } else {\\n+           fire::dbg!(\\"swap\\", &arr[store_index as usize..=last_index as usize]);\\n            arr.swap(store_index as usize, last_index as usize);\\n        }\\n    }\\n+   fire::dbg!(\\"swap\\", &arr[store_index as usize..=pivot as usize]);\\n    arr.swap(store_index as usize, pivot as usize);\\n    store_index\\n}\\n```\\n\\nThis time the swap is shown in the variables of the partition function.\\nAs expected, we see 3 swaps. This should help us to observe the pattern, locate and fix the bug \ud83d\udd0e!\\n\\n<Image src=\\"/img/gt-unit-test-dbg-light.png\\"/>\\n\\n### Debugging Integration Tests\\n\\nSimilar to unit test, we can debug integration test with FireDBG. Let\'s add an integration test file:\\n\\n```rust title=\\"quicksort/tests/bookshelf.rs\\"\\n#[test]\\nfn test_quicksort_1() {\\n    let mut books = [\\n        \\"The Rust Programming Language\\",\\n        \\"Beginning Rust: From Novice to Professional\\",\\n        \\"Rust in Action\\",\\n        \\"Programming Rust: Fast, Safe Systems Development\\",\\n        \\"Rust Programming Language for Beginners\\",\\n    ];\\n    quicksort::run(&mut books);\\n    assert_eq!(\\n        books,\\n        [\\n            \\"Beginning Rust: From Novice to Professional\\",\\n            \\"Programming Rust: Fast, Safe Systems Development\\",\\n            \\"Rust Programming Language for Beginners\\",\\n            \\"Rust in Action\\",\\n            \\"The Rust Programming Language\\",\\n        ]\\n    );\\n}\\n```\\n\\n<Image src=\\"/img/gt-integration-test-light.png\\"/>\\n\\nAlternatively, you can debug integration test with the CLI:\\n\\n```shell\\nfiredbg test bookshelf test_quicksort_1\\n```\\n\\n### Debugging Binary Targets\\n\\nLet\'s create an executable program. We need to add some dependencies first.\\n\\n```diff title=\\"Cargo.toml\\"\\n[dependencies]\\nfiredbg-lib = \\"0.1\\"\\n+ fastrand = \\"2\\"\\n+ structopt = \\"0.3\\"\\n```\\n\\n```rust title=\\"quicksort/src/main.rs\\"\\nuse firedbg_lib::fire;\\nuse std::iter::repeat_with;\\nuse structopt::StructOpt;\\n\\n#[derive(StructOpt, Debug)]\\nstruct Opt {\\n    /// Random seed\\n    #[structopt(long, default_value = \\"2525\\")]\\n    seed: u64,\\n    /// Number of random numbers to be sorted\\n    #[structopt(default_value = \\"10\\")]\\n    n: usize,\\n}\\n\\nfn main() {\\n    let Opt { seed, n } = Opt::from_args();\\n\\n    fire::dbg!(&seed);\\n    fire::dbg!(&n);\\n\\n    fastrand::seed(seed);\\n\\n    let max = if n <= 10 { 100 } else { 1000 };\\n\\n    println!(\\"Sort {n} numbers in ascending order\\");\\n    let mut numbers: Vec<_> = repeat_with(|| fastrand::i32(1..max)).take(n).collect();\\n\\n    println!(\\"Input:  {:?}\\", numbers);\\n    quicksort::run(&mut numbers);\\n    println!(\\"Sorted: {:?}\\", numbers);\\n\\n    let mut c = 0;\\n    for n in numbers {\\n        assert!(n >= c);\\n        c = n;\\n    }\\n}\\n```\\n\\n<Image src=\\"/img/gt-binary-light.png\\"/>\\n\\nWe can use the FireDBG CLI to pass additional parameters to the Rust binary:\\n\\n```shell\\n# Randomly generate 18 numbers with the random seed 2828, then sort it in ascending order\\nfiredbg run quicksort -- 18 --seed 2828\\n```\\n\\n### Debugging Examples\\n\\nExamples work the same as binary targets, just that they are located under the `examples/` directory.\\n\\nWe can also debug example with the CLI:\\n\\n```shell\\nfiredbg example random100\\n```\\n\\n### `firedbg/` Output Folder\\n\\n<Image src=\\"/img/gt-firedbg-folder-light.png\\"/>\\n\\nA `firedbg` folder will be created for storing the symbols, debug runs and other supporting files.\\nYou should ignore this folder from your source control, i.e. add `firedbg/` to `.gitignore`.\\n\\n### `firedbg.toml` Config\\n\\nLet\'s try and add one more crate to the workspace.\\n\\n```shell\\n$ cargo new --lib book-store\\n$ cd book-store\\n```\\n\\nUpdate the `Cargo.toml` at workspace root, adding our new `book-store` package.\\n\\n```toml title=\\"Cargo.toml\\"\\n[workspace]\\nmembers = [\\"quicksort\\", \\"book-store\\"]\\n```\\n\\nBelow we have a simple function to list the inventory in alphabetical order.\\n\\n```rust title=\\"book-store/src/lib.rs\\"\\nuse anyhow::Result;\\nuse std::fs::File;\\nuse std::io::{BufRead, BufReader};\\n\\npub fn inventory(path: &str) -> Result<Vec<String>> {\\n    let file = File::open(path)?;\\n    let reader = BufReader::new(file);\\n\\n    let mut books = Vec::new();\\n    for line in reader.lines() {\\n        let book = line?.trim().to_owned();\\n        books.push(book);\\n    }\\n    quicksort::run(&mut books);\\n    Ok(books)\\n}\\n```\\n\\nTo put it in action we can add a `books.txt` file to the package root and then write a unit test to invoke the `inventory` function.\\n\\n```txt title=\\"book-store/books.txt\\"\\nThe Rust Programming Language\\nRust Programming Language for Beginners\\nProgramming Rust: Fast, Safe Systems Development\\nBeginning Rust: From Novice to Professional\\nRust in Action\\n```\\n\\n```rust title=\\"book-store/src/lib.rs\\"\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    use anyhow::Result;\\n\\n    #[test]\\n    fn test_inventory_1() -> Result<()> {\\n        let path = concat!(env!(\\"CARGO_MANIFEST_DIR\\"), \\"/books.txt\\");\\n        let books = inventory(path)?;\\n        assert_eq!(\\n            books,\\n            [\\n                \\"Beginning Rust: From Novice to Professional\\",\\n                \\"Programming Rust: Fast, Safe Systems Development\\",\\n                \\"Rust Programming Language for Beginners\\",\\n                \\"Rust in Action\\",\\n                \\"The Rust Programming Language\\",\\n            ]\\n        );\\n        Ok(())\\n    }\\n}\\n```\\n\\nUmm... we see that function calls to the `quicksort` crate are missing in the call tree.\\n\\n<Image src=\\"/img/gt-book-store-light.png\\"/>\\n\\nBy default FireDBG will only trace the functions of the debug target.\\nIf you want to trace other crates in your local workspace, you will need to create a `firedbg.toml` config file in your workspace root.\\n\\n```toml title=\\"firedbg.toml\\"\\n[workspace.members]\\nquicksort = { trace = \\"full\\" } \\n# Syntax: <PACKAGE> = { trace = \\"<full | none>\\" }\\n```\\n\\nNow, we can see the function calls of the `quicksort` crate!\\n\\n<Image src=\\"/img/gt-trace-config-light.png\\"/>\\n\\n## The Event Index\\n\\nWhen you open a `.firedbg.ss` file, FireDBG indexer will create a `.sqlite` file to store the analyzed debug info.\\nYou can also run the indexer manually with the `firedbg index` sub-command. You can now write SQL queries to your heart\'s content!\\n\\n<Image src=\\"/img/gt-sqlite-light.png\\"/>\\n\\n[^1]: Supported Linux distributions: Ubuntu 22.04, Ubuntu 20.04, Debian 12, Fedora 39\\n[^2]: Supported macOS versions: macOS 13 (Ventura), macOS 14 (Sonoma)\\n[^3]: Supported Windows (WSL 2) distributions: Ubuntu 22.04, Ubuntu 20.04"},{"id":"2023-12-12-introducing-firedbg","metadata":{"permalink":"/blog/2023-12-12-introducing-firedbg","editUrl":"https://github.com/SeaQL/firedbg.sea-ql.org/edit/main/FireDBG/blog/blog/2023-12-12-introducing-firedbg.mdx","source":"@site/blog/2023-12-12-introducing-firedbg.mdx","title":"Introducing FireDBG for Rust","description":"Debugging programs is hard","date":"2023-12-12T00:00:00.000Z","formattedDate":"December 12, 2023","tags":[{"label":"news","permalink":"/blog/tags/news"}],"readingTime":12.03,"hasTruncateMarker":false,"authors":[{"name":"Chris Tsang","title":"FireDBG Team","url":"https://github.com/tyt2y3","imageURL":"https://avatars.githubusercontent.com/u/1782664?v=4"}],"frontMatter":{"slug":"2023-12-12-introducing-firedbg","title":"Introducing FireDBG for Rust","author":"Chris Tsang","author_title":"FireDBG Team","author_url":"https://github.com/tyt2y3","author_image_url":"https://avatars.githubusercontent.com/u/1782664?v=4","image":"https://firedbg.sea-ql.org/img/banner-introducing-firedbg.png","tags":["news"]},"prevItem":{"title":"Getting Started","permalink":"/blog/2023-12-13-getting-started"},"nextItem":{"title":"Architecture of FireDBG","permalink":"/blog/2023-12-11-architecture-of-firedbg"}},"content":"import { Video, Image } from \'../src/themed.js\';\\n\\n## Debugging programs is hard\\n\\nDebugging programs is hard. It is extremely mind boggling when something does not work as expected. More often than not 90% of the work is on tracking down *where* the bug is, and 10% is actually solving it!\\n\\nBut why don\'t programmers use debuggers more often these days? Instead, we all enjoy adding `println` all over the place, running the program, adding more prints, rinse and repeat, just to find out that we still haven\'t printed the key variable and may even need to make guesses about the program state while drowning in the logs.\\n\\nA running program is like a blackbox to us, and the console is our only window into its internal states. However, at the end of the day, it is still the programmer\'s responsibility to print the relevant information.\\n\\nHow does a debugger help us debug a program? We identified that it usually comes down to:\\n\\n+ Where did the control flow of my program go?\\n+ Where do my errors come from?\\n+ What are inside my variables?\\n+ What happened in what order?\\n\\n### That\'s why we created FireDBG - a Time Travel Visual Debugger for Rust \ud83c\udfac\\n\\n<Video src=\\"/img/quicksort-mac-light.mp4\\" />\\n\\n## Time travel debugging\\n\\nAccording to Wikipedia, time travel debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. Unlike \\"traditional\\" debuggers which can only step forward, time travel debuggers allow us to step backward and see the cause and effects.\\n\\nTime travel debuggers exist[^1], and they usually work by recording data on the instruction level. But that would result in a gigantic amount of data, so now the question is: how do we make sense of this data and *navigate through time* effectively?\\n\\n## Call tree - the trail across the forest\\n\\nLet\'s take a look at the following call tree for an implementation of quicksort:\\n\\n```rust\\npub fn run<T: PartialOrd>(arr: &mut [T]) {\\n    let len = arr.len();\\n    quick_sort(arr, 0, (len - 1) as isize);\\n}\\n\\nfn quick_sort<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) {\\n    if low < high {\\n        let p = partition(arr, low, high);\\n        quick_sort(arr, low, p - 1);\\n        quick_sort(arr, p + 1, high);\\n    }\\n}\\n\\nfn partition<T: PartialOrd>(arr: &mut [T], low: isize, high: isize) -> isize {\\n    let pivot = high as usize;\\n    let mut store_index = low - 1;\\n    let mut last_index = high;\\n\\n    loop {\\n        store_index += 1;\\n        while arr[store_index as usize] < arr[pivot] {\\n            store_index += 1;\\n        }\\n        last_index -= 1;\\n        while last_index >= 0 && arr[last_index as usize] > arr[pivot] {\\n            last_index -= 1;\\n        }\\n        if store_index >= last_index {\\n            break;\\n        } else {\\n            arr.swap(store_index as usize, last_index as usize);\\n        }\\n    }\\n    arr.swap(store_index as usize, pivot as usize);\\n    store_index\\n}\\n```\\n\\n<Image src=\\"/img/quicksort-light.png\\">\\n    FireDBG screenshot for an <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/quicksort\\">implementation of quicksort</a>\\n</Image>\\n\\n\\nIf you instantly get it, you can skip this section! If not, let\'s go through it step by step:\\n\\n> \\"A call tree is all the state transitions of a program\'s call stack laid out on a 2D plane, organized in form of a tree\\"\\n\\nEvery time a function call is made, we create a child node; when the function returns, we go back to the parent node. So subsequent function calls become sibling nodes.\\n\\n<Video src=\\"/img/calltree-light.mp4\\" />\\n\\n<p></p>\\n\\nAt any given node, traversing up to the root node gives us a chain - which is the call stack.\\nWe have two notations, `--\x3e--` for function calls; `--<->--` for function calls with return values.\\nWe assign a unique frame ID to each node and this is the time sequence used in the timebar.\\n\\n## Call tree visualization and algorithms\\n\\nFireDBG is built around the call tree. You may ask, wouldn\'t this call tree become very large? Yes, that\'s why we spent enormous effort into linearizing everything. We developed a streaming file format to process the data in real time, and figured out a layout algorithm that can render infinite trees.\\n\\nWhat\'s so interesting about call trees? Their shapes reveal a lot about the properties of algorithms. To illustrate, here\'s a side-by-side comparison of quicksort and mergesort, and we can see that quicksort yields a deeper tree than mergesort[^2]. So quicksort is using more stack memory[^3] than mergesort, which makes sense because mergesort uses some memory on the heap!\\n\\nSince both are binary trees, they are not tail-call optimizable. And since both algorithms claim to be of `O(n log n)`, statistically only one of the two branches should grow deeper. There are a lot more to observe and I have been drawing this on paper by hand for many years.\\n\\n<Image src=\\"/img/quicksort-vs-mergesort-light.png\\">\\n    Comparing <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/quicksort\\">quicksort</a> and <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/mergesort\\">mergesort</a> side by side with the same input\\n</Image>\\n\\n## Tracing errors - the error path\\n\\nThis might be a Rust specific problem: Rust don\'t have exceptions. Instead, Rust uses a `Result` system coupled with the ergonmic `?` operator to effectively signal and handle errors. This has both pros and cons - the good thing is that errors propagate back to the parent along the exact same path the function is being called, which is deterministic and predictable. The bad thing is, when you finally `unwrap` an error and decide to panic, the context of the error has long been lost.\\n\\nThis echos our second question: where do my errors come from? Consider the following toy program, where we get to roll some dice and each time we could be rolling one, two or three dice. Once in a while, throwing a die can cause an error. This is deliberately randomized, so there is no way to statically analyze where the error might come from - such is life!\\n\\n```rust\\nfn roll(i: i32) -> Result<(), ()> {\\n    let (a, b, c) = (dice(i), dice(i), dice(i)); a?; b?; c?;\\n    if fire::dbg!(fastrand::u32(0..4)) == 0 {\\n        roll(i - 1)\\n    } else {\\n        throw(i - 1)\\n    }\\n}\\n\\nfn throw(i: i32) -> Result<(), ()> {\\n    match fire::dbg!(fastrand::i32(1..=3)) {\\n        1 => { let a = dice(i); a?; }\\n        2 => { let (a, b) = (dice(i), dice(i)); a?; b?; }\\n        3 => { let (a, b, c) = (dice(i), dice(i), dice(i)); a?; b?; c?; }\\n        _ => unreachable!(),\\n    }\\n    if fire::dbg!(fastrand::bool()) {\\n        roll(i - 1)\\n    } else {\\n        throw(i - 1)\\n    }\\n}\\n\\nfn dice(i: i32) -> Result<(), ()> {\\n    if fire::dbg!(fastrand::i32(0..i)) == 0 { Err(()) } else { Ok(()) }\\n}\\n\\nfn main() {\\n    roll(25).unwrap();\\n}\\n```\\n\\nFireDBG captures all functions\' return values and so is able to locate where the error originated from and how it propagated up! Here is the rendered call tree of this `roll_dice` program, where FireDBG is able to highlight the error path up until the point of panic, which is conveniently marked by `!`:\\n\\n<Image src=\\"/img/roll_dice-light.png\\">\\n    A screenshot of the <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/roll_dice\\"><code>roll_dice</code></a> call tree\\n</Image>\\n\\n## Collecting parameters and return values\\n\\nAs you have seen in the above screenshots, FireDBG captures all functions\' parameters and return values. Capturing parameters is the easy part, because it\'s a basic feature of any debuggers[^4]. But capturing return values is a little intricate. The current implementation is: we set a breakpoint at every `ret` instruction and capture the return value at that *particular* point in time. The next instruction will immediately jump back to the parent function, which may overwrite the value.\\n\\nLet\'s talk about ABI. There are different call conventions and Rust is particularly flexible in whether a value is returned via stack or register. In some cases complex data can be packed into one register, because Rust can return complex types like tuples and unions[^5]. We tried super hard, but return value capture is still a hit-or-miss, but some visibility is better than no visibility!\\n\\n<Image src=\\"/img/quicksort-partition-light.png\\">\\n    Inspecting the parameters and return value of the <code>partition</code> function\\n</Image>\\n\\n## A type system for the Rust type system\\n\\nWe rely on lldb\'s awesome `SBType` API to parse Rust\'s debug symbols, and capture variables\' values in binary forms - not all things are printable, in particular, pointers (references) and containers. We have to reference the memory locations to get their values. This becomes non-trivial if the references form a diamond or worse, cycles[^6].\\n\\nFor pointers, our brilliant intern[^7] has a great idea - capture and store the pointees as context for each variable and dereference those pointers on replay. Each memory address will only be serialized once, but can be copied many times on deserialization.\\n\\nAs such, we were able to construct a type system that can [represent Rust values](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/protocol/src/value.rs), which are serialized as binary data. We can then visualize them beautifully!\\n\\n<Image src=\\"/img/car-light.png\\">\\n    The <a href=\\"https://github.com/SeaQL/FireDBG.for.Rust/blob/main/debugger/testcases/object.rs\\"><code>Car</code> data structure</a> with visualization; left panel: Rust definition\\n</Image>\\n\\nFor containers, it is more murky. For vectors, we can simply read a blob of memory from the heap, because the items are contiguous. But ... how about hash maps? Luckily, in Rust, the standard library\'s hashmap is a [flat hashmap](https://github.com/rust-lang/hashbrown), which means items are densely packed, although not contiguous. So with some [memory fiddling](https://github.com/tyt2y3/frozen-hashbrown), we are able to capture the contents of hashmaps!\\n\\nNote that in the screenshot below, the hash key is `&str`, which means after extracting the hash keys from the hash map, we have to dereference the pointers to retrieve the string content.\\n\\n<Image src=\\"/img/hashmap-light.png\\">\\n    Left panel: captured hashmap; middle panel: rendered hashmap; right panel: raw representation of a hashmap\\n</Image>\\n\\n## A new lens into our code\\n\\nVisualization is a new lens into our code. Above are just a few simple examples, and FireDBG opens the door to domain-specific visualizations that are meaningful to us. Below are a few more examples:\\n\\n<Image src=\\"/img/sudoku-light.png\\">\\n    A <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/sudoku\\">Sudoku solver</a>\\n</Image>\\n\\n<Image src=\\"/img/tokenizer-light.png\\">\\n    A <a href=\\"https://github.com/SeaQL/sea-query/blob/master/src/token.rs\\">SQL tokenizer</a>\\n</Image>\\n\\n<Image src=\\"/img/bubble-code-light.png\\">\\n    My personal favourite - <a href=\\"https://github.com/SeaQL/FireDBG.Rust.Testbench/tree/main/bubble-code\\">symbolic recognition</a>\\n</Image>\\n\\n## I want to debug *my code* - not system libraries!\\n\\nWe tried our best to boost the signal-to-noise ratio. Instead of `alloc::sync::Arc { core::ptr::non_null::NonNull { alloc::sync::ArcInner { strong: core::sync::atomic::AtomicUsize { .. }, weak: core::sync::atomic::AtomicUsize { .. }, data: pointer::Object { .. } } } }`, we try to prettify standard library types like `Arc` as `RefCounted { strong: 1usize, weak: 1usize, value: pointer::Object { .. } }`.\\n\\nFireDBG only traces user code - not standard library, not vendor libraries - only the code inside the specific crate you are currently programming. Which means the call tree will only contain functions you wrote. No implementation details like `<I as alloc::vec::in_place_collect::SpecInPlaceCollect<T,I>>::collect_in_place`.\\n\\nWhich also means that the overhead of program tracing is confined - even with a very complex program, the subset of user code that we want to trace would only be a fraction of the program binary.\\n\\n## Multi-threaded programming \ud83c\udfac\\n\\n<Video src=\\"/img/timeline-mac-light.mp4\\" />\\n\\nRust\'s slogan is \\"Fearless Concurrency\\", so how do we debug multi-threaded Rust programs? It\'s possible to pause and step through a multi-threaded program, but doing so manually would affect the timing and synchronization of other threads.\\n\\nFireDBG can track multiple threads and keep them running as smoothly as possible, allowing us to observe how multiple threads work together. It\'s a proof-of-concept, but let\'s take a look at a small Rust program that spawns multiple worker threads to perform matrix computation:\\n\\n```rust\\nfn inverse(m: &Matrix<D, D>) -> Option<Matrix<D, D>> {\\n    fire::dbg!(\\"return\\", Matrix::inv(m))\\n}\\n\\nfn runner(receiver: Receiver<Matrix<D, D>>, sender: Sender<(Matrix<D, D>, Option<Matrix<D, D>>)>) {\\n    while let Ok(m) = receiver.recv() {\\n        // send back the input with solution\\n        let mm = inverse(&m);\\n        sender.send((m, mm)).unwrap();\\n    }\\n}\\n\\nfn main() {\\n    let (result, collector) = channel();\\n    let mut senders = Vec::new();\\n    for _ in 0..THREADS {\\n        // spawn worker threads\\n        let (sender, receiver) = channel();\\n        senders.push(sender);\\n        let result = result.clone();\\n        std::thread::spawn(move || runner(receiver, result));\\n    }\\n\\n    for c in 0..ITEMS {\\n        // spmc; fan out\\n        let m = Matrix::<D, D>::random();\\n        senders[c % THREADS].send(m).unwrap();\\n    }\\n\\n    for _ in 0..ITEMS {\\n        // mpsc; consolidate\\n        let (m, mm) = collector.recv().unwrap();\\n        println!(\\"Source  = {m:?}\\");\\n        println!(\\"Inverse = {mm:?}\\");\\n    }\\n}\\n```\\n\\n<Image src=\\"/img/multi-thread-light.png\\">\\n    Top panel: a matrix and its inverse computed by a worker thread; bottom panel: timeline showing events across all threads within a specific time window\\n</Image>\\n\\n## The vision\\n\\nWhat you see today is an MVP of FireDBG. It may be slow and buggy, and notably, async Rust support is still a work-in-progress. But it outlines the vision I have for what a debugger could be and how it can level up our debugging experience. I still have a dozen of visualization ideas: channels, mutexes, arc/rc graph, async timeline, etc.\\n\\nWe aim to bring FireDBG to other programming languages and engineering domains. Our ultimate goal is to improve the debugging experience for all developers!\\n\\n## Let\'s work together!\\n\\n### Call for stargazers\\n\\nPlease star our [GitHub repo](https://github.com/SeaQL/FireDBG.for.Rust)! Your support is vital. Even if you are not a Rust developer, let us know your thoughts too.\\n\\n### Call for early adopters\\n\\nIf you think your use case can be drastically improved by having a visual debugger, let\'s collaborate and shape the product together[^8].\\n\\n### Call for co-founder\\n\\nI am looking for a co-founder. If you are like me, deeply passionate about developer experience and willing to commit to this idea, let\'s team up and embark on a journey to transform software engineering. You can find my profile on [YC Co-Founder Matching](https://www.startupschool.org/cofounder-matching/candidate/hy22iDvPx)[^9].\\n\\n## Acknowledgement\\n\\nMany great software inspired me, but two of them is worth mentioning: [Firebug](https://getfirebug.com/index.html) and [Flame Graph](https://www.brendangregg.com/flamegraphs.html). Firebug changed web development forever, and is the predecessor to the awesome browser developer tools we enjoy today.\\n\\nFlame Graph is the classic example of how a simple but powerful idea became ubiquitous, and it really demonstrates the magic of visualization. Good visualization enlightens our brains.\\n\\nA huge thanks to the [CodeLLDB](https://github.com/vadimcn/codelldb) project, which powers FireDBG\'s lldb driver. In case you\'re wondering, FireDBG uses both [SeaORM](https://github.com/SeaQL/sea-orm) and [SeaStreamer](https://github.com/SeaQL/sea-streamer) under the hood. And of course none of this could be possible without the Rust programming language and the awesome Rust community!\\n\\n[^1]: [WinDBG](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview), [rr](https://rr-project.org/)\\n[^2]: Probably because of bad pivot selection\\n[^3]: A deep call stack could harm performance or at least pose a risk of overflow\\n[^4]: Except not really, in some cases the function prologue is wrong\\n[^5]: A future blog post will be published to explain the intricacies\\n[^6]: Although normal, safe Rust programs should not have reference cycles\\n[^7]: Who would rather not be named\\n[^8]: Feel free to reach us via GitHub or email\\n[^9]: Please do not DM me; let\'s connect on the platform"},{"id":"2023-12-11-architecture-of-firedbg","metadata":{"permalink":"/blog/2023-12-11-architecture-of-firedbg","editUrl":"https://github.com/SeaQL/firedbg.sea-ql.org/edit/main/FireDBG/blog/blog/2023-12-11-architecture-of-firedbg.mdx","source":"@site/blog/2023-12-11-architecture-of-firedbg.mdx","title":"Architecture of FireDBG","description":"Under the hood of FireDBG","date":"2023-12-11T00:00:00.000Z","formattedDate":"December 11, 2023","tags":[{"label":"news","permalink":"/blog/tags/news"}],"readingTime":7.2,"hasTruncateMarker":false,"authors":[{"name":"Chris Tsang","title":"FireDBG Team","url":"https://github.com/tyt2y3","imageURL":"https://avatars.githubusercontent.com/u/1782664?v=4"}],"frontMatter":{"slug":"2023-12-11-architecture-of-firedbg","title":"Architecture of FireDBG","author":"Chris Tsang","author_title":"FireDBG Team","author_url":"https://github.com/tyt2y3","author_image_url":"https://avatars.githubusercontent.com/u/1782664?v=4","image":"https://firedbg.sea-ql.org/img/dataflow-dark.png","tags":["news"]},"prevItem":{"title":"Introducing FireDBG for Rust","permalink":"/blog/2023-12-12-introducing-firedbg"}},"content":"import { Image } from \'../src/themed.js\';\\n\\n## Under the hood of FireDBG\\n\\n<Image src=\\"/img/components-dark.png\\">\\n    Component diagram of FireDBG\\n</Image>\\n\\n### `firedbg-cli`\\n\\n`firedbg-cli` drives everything. It acts as a proxy to `cargo`, so a `cargo run` command becomes `firedbg run`, `cargo test` becomes `firedbg test` and so on. `firedbg-cli` also relies on `cargo` to list all the executable targets shown in the \\"Run and Debug\\" tab of VS Code.\\n\\n### `parser`\\n\\n`firedbg-parser` parses all source files in the workspace and outputs a symbol table per file. These `.map` files are cached, so they will be reused if the source files are unchanged since the last parse.\\n\\n### `debugger`\\n\\n`firedbg-debugger` is the debugging engine of FireDBG. It is configured according to `firedbg.toml`. The debugger drives the target process via `lldb` and streams the breakpoint events in real-time. The output file, with the extension `.firedbg.ss`, follows the binary file format defined in [SeaStreamer File](https://github.com/SeaQL/sea-streamer#sea-streamer-file-file-backend).\\n\\nIt sometimes uses `rustc` on the host for miscellaneous things.\\n\\n### `indexer`\\n\\n`firedbg-indexer` is a streaming indexer. It can stream events from the `.firedbg.ss` file and process them in real-time. It outputs a `.sqlite` file with the same name, using [SeaORM](https://github.com/SeaQL/sea-orm) to drive SQLite. The index enables the GUI to quickly look up the call chain and frame info.\\n\\n## Mode of operation\\n\\n### Overview\\n\\n<Image src=\\"/img/dataflow-dark.png\\">\\n    Data flow diagram of FireDBG\\n</Image>\\n\\nThe basic idea of FireDBG is to automate the actions done by a user on a debugger CLI/TUI/GUI. For example, a user would usually set some breakpoints at some strategic locations and inspect all local variables every time a breakpoint is hit. FireDBG does the same! But our goal is to make each breakpoint hit as brief as possible, in order to keep the program-under-debug running in real-time. This is important because some resources like sockets and timers are time sensitive.\\n\\nThis mode of operation is called \\"galloping\\"[^1], as it only breaks on user code - library code and system calls are all skipped. In other words, the call tree we construct is not the full process call tree; it\'s down-sampled. In theory, we can use a VM to execute and record[^2] the process, then run it through FireDBG to condense the data.\\n\\nThe thesis is: \\"too much details obfuscate our understanding\\", and more often than not, we want to see the big picture. FireDBG lays out the call tree on a plane, so our brain can make sense of the two-dimensional space. The UX of the GUI is designed based on modern interactive maps[^3].\\n\\n### Static Analysis\\n\\nWe parse the Rust source files with `syn`, looking for all functions, methods, and trait implementation blocks. The location and span of these functions are then dumped into `.map` files. In the future, we\'re hoping to support constructing a static call graph, so as to allow the debugger to only set breakpoints at functions reachable from `main` (or the program entry point, whatever it is).\\n\\n### Runtime Debugging\\n\\nOn startup, the symbol tables are read. After loading the target executable into memory, the debugger loads the corresponding symbol tables and set breakpoints at those functions according to the configuration. We also set breakpoints on the panic handler and heap allocators.\\n\\nThe program will then be run. The debugger keeps a logical stack model for each thread. On each function call, a new frame ID will be assigned. The tuple (thread ID, frame ID, function call) uniquely identifies any point in program execution.\\n\\nWhen a function is first called, we disassemble it. Then breakpoints are set at all `ret` instructions, so that whenever the function returns, the breakpoints will be hit, and a function return event is recorded. (We also cache the `SBType` definition of the function, with which the function return handler can salvage the return value from the registers, but this is an implementation detail). All parameters of the function are captured once the program has gone past the prologue[^4].\\n\\nAll breakpoint events happening meanwhile will be tagged with the current frame ID in the current thread.\\n\\nAll events will be streamed out in real-time. The format of the stream events is defined in [`firedbg-protocol`](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/protocol).\\n\\n#### Multi-threading\\n\\nIt is actually possible to debug multiple threads by hand using a conventional GUI debugger, you just need to know this one trick ;)\\n\\nMultiple threads can be hitting the same breakpoint at the same time, so we need to inspect all the threads each time a breakpoint is hit. We look at the PC address to determine whether this thread was actually paused on a breakpoint, and if so, record the event. All threads are resumed as soon as possible.\\n\\n### Value Capture\\n\\nValue capture is currently done via `lldb`\'s excellent `SBValue` / `SBType` API. There are some edge cases, particularly around Rust\'s \\"complex enums\\" aka union types. There are many hacks[^5] done by [`firedbg-debugger`](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/debugger/src/debugger.rs) to [capture various Rust standard types](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/debugger/src/value/writer.rs), including but not limited to `Vec<u8>`, `&str`, `&dyn T`, `Rc/Arc`, `HashMap`.\\n\\n[Return value capture](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/debugger/src/debugger/return_value.rs) is currently done by looking at the return type and guessing where it will be placed at, registers or stack, and salvage the value. More ideally, we would query the call convention and extract accordingly.\\n\\nAll values are serialized as binary blobs in native endian. There are several motivations: 1) faithfulness 2) avoiding floating point and utf-8 idiosyncrasies[^6] 3) avoiding serialization to strings which is slow 4) smaller file size.\\n\\n### Event Index\\n\\nThe indexer reconstructs the call stack for each thread from the event stream. It then represents the call trees in SQL by self-references[^7]. It also performs basic analysis like counting hits for each breakpoint.\\n\\nThe indexer deserializes the value blobs and transforms them into pretty-printed strings and JSON. They will then be queried by the GUI for display and visualization.\\n\\nThe [SeaORM schema](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/indexer/src/entity/) is defined in [`firedbg-indexer`](https://github.com/SeaQL/FireDBG.for.Rust/blob/main/indexer/).\\n\\n## Parallelism\\n\\n<Image src=\\"/img/parallelism-dark.png\\">\\n    Parallelism in FireDBG; outer boxes: processes; inner boxes: threads\\n</Image>\\n\\nA lot of effort has been put in making FireDBG to improve responsiveness. The previous diagram shows the pipeline where data is streamed real-time. This diagram gives a different perspective: how the components work in parallel.\\n\\nThe Debugger, Indexer and GUI are separate processes, and each uses multiple threads for stream producer and consumer. Except in node.js the streamer is a subprocess instead of a thread.\\n\\nThe Call Tree Renderer is incremental: nodes are added on canvas as they arrive.\\n\\n## Support for other languages\\n\\nOur vision is to bring FireDBG to *all* programming languages. Some possible candidates are:\\n\\n+ C++: supported by `lldb`; but it is difficult to distinguish user code from library code\\n+ Swift: supported by `lldb`; but need to support a lot of Apple system stuff\\n+ Go: `delve` seems very API drivable!\\n+ node.js: we can use the DevTools Protocol\\n+ Python: `debugpy` seems very promising\\n+ Your favourite language: suggestions are welcome!\\n\\nWhen designing this architecture, we have been keeping in mind how we\'d piece in other languages. Each language would have its own `firedbg-xxx-debugger`, outputting the same `.firedbg.ss` stream protocol. Primitives can more or less be shared so we can reuse the same `PValue`. `RValue` actually stands for \\"Rust Value\\", so you can assume we\'d have `GoValue` for Go, `JsValue` for Javascript, etc.\\n\\nWe will ship multiple `indexer` binaries, but they will likely share the same codebase.\\n\\nThe CLI will be each implemented in its own language.\\n\\nThe GUI will all share the same codebase, but of course each language will have its own VS Code extension.\\n\\nRust probably has the most complex type system[^8], hopefully it will not get much more complicated than what we have already implemented.\\n\\nThe async programming model should be similar among languages, so we should be able to visualize them under the same model.\\n\\n### Pure functional languages\\n\\nThe call tree visualization is universal to all programming languages[^9]. Other than that I have not thought about other parts yet.\\n\\n[^1]: Or \\"tiptoeing\\", which is better?\\n[^2]: Or `rr`, but we don\'t have a gdb driver yet\\n[^3]: You can pan with click-and-drag (or three finger drag on macOS), scroll to zoom; we also have (x, y) coordinates: x-axis is the depth, y-axis is the breadth in the tree\\n[^4]: Sometimes the function prologue is wrong and FireDBG currently has some logic to guess the prologue\\n[^5]: Many; maybe in the next version we will abandon debug symbols altogether\\n[^6]: They are not interpreted on serialization; only on deserialization which is the job of the indexer\\n[^7]: If we have a MySQL backend, a single recursive CTE query can reconstruct the call chain of a given frame\\n[^8]: *Probably*\\n[^9]: We can probably make one for [Lisp](https://lispcookbook.github.io/cl-cookbook/debugging.html#trace) too"}]}')}}]);